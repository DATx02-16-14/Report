\documentclass[a4paper]{article}

\usepackage{preamble}
\begin{document}

\maketitle
\pagenumbering{gobble}
\vfill

\begin{center}
\large
Computer Science and Engineering\\
\textsc{Chalmers University of Technology} \\
Gothenburg, Sweden 2016 \\
\normalsize
\end{center}

\newpage
\section*{Abstract}
\section*{Sammandrag}
\section*{Keywords}
\newpage
\listoftodos
\tableofcontents
\listoffigures

\newpage
\pagenumbering{arabic}

\section{Introduction}
\subsection{Purpose of the project}
\label{sec:purpose}
\todo{Change purpose to include Haste.App in first sentence since we focus a lot of Haste.App and secondarily on functional languages.}
The purpose of the report is to discuss and evaluate the advantages and disadvantages of writing client-server applications with all of the properties of using a purely functional language. For this purpose the language used will be Haskell with the libraries Haste and Haste.App. Using these tools a game and a lobby will be developed. More specifically it will investigate whether or not there will be any effect on performance, if there will be any advantages in regards to programmer productivity, and if there will be any observable benefits regarding the stability of the application. An additional purpose of the project is to supply comments and feedback on Haste and Haste.App back to the developer, who is a Ph.D student at Chalmers.

\subsection{Limitations for the project}
The work will not assess demanding real-time applications and graphics using Haste.App, since the focus of the project is mainly assessing the suitability of using Haskell to program for the web using Haste.App. Neither will a second product using a more traditional library be created for the purpose of comparing performance, stability and programmer productivity.

\subsection{Background}
% The background of the project
Writing web applications typically involves incorporating JavaScript for a large portion of the code. JavaScript has many benefits such as being very popular thus having a rich set of libraries. It is also good for prototyping since it is a simple and dynamically typed language. Haskell, on the other hand, is a strongly typed language with an advanced type system. Strongly typed languages can make it harder to create a simple prototype. The absence of variables as states could make it is easier to verify that the code is correct \cite{marlow2010haskell}. The ability to do equational reasoning is also greatly simplified \autocite{equational-reasoning}.

Haste is a Haskell to JavaScript compiler. It makes it possible to use the advantages of a purely functional language in a web setting. The Haste compiler aims to produce compact code and is also based on the standard GHC Haskell compiler.

Haste also comes with the Haste.App library which allows both the client- and server-side code to be written in one program\cite{ekblad2015seamless}. The library takes care of the network communication, so the programmer does not have to write it explicitly. It relieves the programmer from this tedious and error-prone task. Haste.App is also pursuing a client-centric programming model. This means that the programmer takes the view of the client when writing the code\cite{a-distributed-haskell-for-the-modern-web}. At the time of writing this thesis Haste.App is still very new and requires a lot more testing and investigation, but the potential rewards are promising.



\subsection{Related research}
There are two ways to look at related research regarding this thesis. The first being a greater overview of functional research, particularly applied functional programming which Chalmers is heavily pursuing. The research done in this thesis is of course just another example of functional programming applied to an area where it is not so commonly used today, namely development of web application.

The other view is research directly related to the work of this thesis. This thesis is of course heavily related to the work of Anton Ekblad, who is the main developer of the Haste compiler and it's accompanying libraries. In his licentiate thesis: A Distributed Haskell for the Modern Web, he describes the implementation of Haste.App and it's potential benefits \cite{a-distributed-haskell-for-the-modern-web}.

In terms of general language X to JavaScript compilers there is also happening a lot. Most languages have an JavaScript compiler that is being developed actively, an example is ClojureScript which is a Clojure to JavaScript compiler.

\subsection{Problem description}
\label{sec:problem}
% Problemanalys. Split the purpose into smaller parts,
To help analyse the purpose, it can be split into several smaller parts. These deal with different aspects of writing client-server applications with the help of Haste.App. As mentioned in \cref{sec:purpose} the purpose can be split into effects on performance, programmer productivity and stability. These are, however, also large and hard to analyse without further breaking them into even smaller parts.


\subsubsection{Performance}
Performance is a crucial aspect when writing client-server applications. On the server side, the application can not use too much system resources. This is important both because it is often desirable to have as inexpensive servers as possible (while maintaining enough performance), and because it allows more clients to be connected to the server. On the client side, the application needs to be efficient to make sure the user's computer continues to run smoothly and that the user does not experience any delays from performance issues. As such it is important that there is not a large discrepancy between using Haste.App and a more traditional client-server approach. There could be several reasons for a large discrepancy happening: Firstly, on the client side, the Haste compiler might generate JavaScript that is slower than expected for some Haskell code. Secondly, the server part of an application written in Haste.App might be considerably slower than using any other framework for client-server applications to be acceptable. In addition it might be of interest for the report to investigate whether it is possible to work around such problems with the compiler. Even though the programmer has to spend extra time rewriting code that already work, the project might still be more effective due to the benefits given by both Haskell and Haste.App.


\subsubsection{Programmer productivity}
\label{sec:programmer_productivity}
Traditional client-server applications forces the programmer to write two different applications, and the communication between them. This can be an error prone and tedious task as it forces the programmer to make sure the types match both on the client and the server. Moreover, the arbitrary communication can make the program flow confusing and difficult to grasp as well as introduce errors. In this traditional model, both the server and client can drive the program flow, something that also serves to make the program flow unpredictable. These are all problems when considering programmer productivity.

Haste.App tries to counter these issues in a number of ways. Most importantly it allows the programmer to write both the client code and the server code in the same file, and makes use of Haskell's static and strong type checking to handle the communication as well as the rest of the code. It also lets the client be the only driving force in the application and uses a synchronous, linear programming model \cite{ekblad2015seamless}. These attempts from Haste.App to counter problems regarding programmer productivity when writing traditional client-server applications might influence programmer productivity in one direction or another.


\subsubsection{Stability}
On a language level Haskell brings many benefits, as it is a strongly typed static language. The static type checking verifies type correctness at compile time which allows bugs which are trivial but hard to find to be tracked down more easily. Another important benefit the type system in Haskell brings is that it allows for pure logic to be separated from its impure counterparts. This type system brings a tremendous benefit by allowing the use of tools like QuickCheck to test the pure logic of the application \cite{Claessen:2011:QLT:1988042.1988046}. Haste.App also extends the static type checking over the network through it's remote procedure calls (RPC), which might remove confusing network errors. Because the distinction of pure and impure code is made so explicit, expressions which are side-effect free become obvious.

The programmer can use these benefits when writing the code with the Haste compiler. Stability will thus be investigated to see if the advantages Haskell brings, in terms of program correctness, is of any practical use when writing client-server applications.

Besides language level correctness, the stability of the Haste compiler needs to be taken into account. Particularly the Haste.App module, which is at the heart of this thesis, can be expected to have errors. While these errors might decrease the stability of the product they will not be the fault of the program itself. This is where giving feedback on Haste and Haste.App becomes important as it will allow for the bugs to be tracked down and fixed.



\section{Technical background}
In this section the techniques used to create the lobby system and the game are described, together with an account of different ways of addressing some of the problems one might encounter during web development.
% To understand what we have done
% For example there are problems with DOM so what is DOM etc.
\subsection{Haskell}
Haskell is a functional language most known for its static typing, pure functional style and lazy evaluation. A functional program consists of a set of declared mathematical functions. These functions have no side effects since they are only evaluated by the arguments which are given to them and cannot be influenced by any outside unpredictability like reading from OS.

Handling side effects, or more generally computational contexts is done by using monads. For programmers unfamiliar with the concept, at a first glance it might seem like an unnecessary obstacle which is a by product of the language being fully functional. Of course there are many benefits of using monads, one obvious being that it effects the type system in a positive way. Because monads are explicitly seen in the type system the programmer can now at a glance see which code runs under what computational context. This of course makes impure from pure functions obvious. This allows for much easier testing of pure functions with tools like QuickCheck, to ensure that the logical part of the program works correctly.

Being a statically language means that all types are resolved at compile time instead of run time like in a dynamically typed language. This has the obvious drawback of the programmer having to explicitly declare every type, thus making it less suitable for quick prototyping. But one also has to consider the great benefits, mainly that trivial bugs can be caught at compile time. Knowing types at compile time also allows the compiler to do various optimization otherwise not possible. The size of the compiled binaries also tend to become smaller and run more quickly because code for checking types during run time can be omitted.

Haskell also offers very compact syntax, and combined with the type notations allows complex code to be expressed much more clearly. The clarity and reduced size of the code makes it easier to digest functionality when reading new code. There is much data supporting the fact that Haskell programs tends to be a lot more concise and smaller than common object oriented and imperative programs. There exists a proportional relationship between the number of bugs and lines of code, generally independent of what language used. This naturally concludes that experienced Haskell programmers tend to be more productive.



\subsection{Haste}
When writing client side applications the programmer often does not have a lot of choice, it nearly always boiles down to JavaScript. Without going into a deeper discussion on why JavaScript has come to dominate the web, this subsection will focus on the Haskell to JavaScript compiler - Haste.

Because JavaScript is so popular the answer to why anyone would write a compiler targeting it is obvious. Besides being popular there are a lot of features JavaScript as a target languages offers compared to more regular
intermediate languages like the JVM. JavaScript has a high abstraction level thus enabling a lot of Haskell functions to be translated directly to a JavaScript counterpart. When compiling to JavaScript one could also make use
of the run time functionality like the garbage collector.

Haste aims to produce lightweight and optimized code. Although it is based
on the GHC compiler it does compromise with GHC support in cases where performance would otherwise suffer. This is a notable
difference compared GHCJS, which primary focuses on being fully compatible with GHC.



\subsection{Haste.App}
\todo{Antar att denna paragrafen ska bort?//Tejp}Haste.App is described in more detail and how it differs from the traditional way of writing client server applications.

Haste.App is a library compatible with the Haste compiler, used for writing network applications.
There are a number of properties that makes Haste.App different in comparison to the traditional way of
writing client-server applications:

Maybe the most notable difference is that both the client and server logic is written in the same program.
This allows for an extension of the powerful type system over the network. It is now possible in compile time
to verify that the type of data the client or server send and receive are correct. It is also easier to
move functionality from the client to the server and vice versa.

Another important benefit of Haste.App is the abstraction of network communication. It is no longer
necessary for the programmer to write the communication between the client and server explicitly. This
of course relives the programmer from having to do this repetitive and error prone task. This will hopefully
have positive effects on productivity but also the correctness of the application.

In a more traditional setting, the client and server logic has to be written in two separate applications. And of course as
contrary to the Haste.App feature, the communication is also needed to be written explicitly by the programmer. Except being
a burden to the programmer, it is also a potential source of new bugs.

Having all the logic in one program might seem to affect what code is actually executed on the client or server side, but
a separation is achieved using the Haskell type system. The code that should only be exectued on the server is wrapped in the
Server monad, and the client code is similarly wrapped in the Client monad.

Uniting the client and server code also requires a different way of compiling the program. The program is first compiled
with GHC which generates the the binary that will be executed on the server. After GHC is done, the program is compiled with
Haste which produces the JavaScript code that will run on the client side.

Haste.App also uses synchronous communication in contrary to the more regularly used asynchronous callbacks.
This gives a more linear program flow allowing to easier reason about about the execution of the program.

\subsection{DOM}
DOM or Document Object Model is a convention for representing certain types of documents, such as HTML. It allows for HTML pages to be written in a hierarchical tree-like manner and it allows for programs to interact with the contents of the page in order to create interactive websites. The DOM in form of HTML can be created in various ways: In a separate file where raw HTML is accepted, the DOM created in the file can then be read by the program and interacted with. It can also be created directly using JavaScript or, in the case of this project, Haste. Another approach is using some external library created for use in with Haste to create DOM.


\subsection{Dependencies}
\todo{Hör dependencies hemma under technical background? Det är väll mer ett problem vi stötte på under utvecklingen av lobbyn som vi löste.}
\label{sub:dependencies}
% Vilket probem vi har med att haste inte kompilerar ghc bibliotek och hur vi hanterar det.
Like any other project, hastings have dependencies on external libraries. Since the project is compiled using two compilers, haste and ghc, one could imagine that haste should be able to compile anything which ghc can. This is not the case. Since haste compiles the client code and ghc compiles the server, the question boils down to: How can we continue using haskell libraries in our Haste.App application but make sure only the ghc compiler is aware of it? Looking at hastings an example can be made of the relation between \textit{Main.hs}, which needs to be compiled with both ghc and haste, and \textit{LobbyServer.hs} and \textit{LobbyClient.hs} which need to be compiled by ghc and haste respectively.
\textit{Main.hs} needs to import both \textit{LobbyServer.hs} and \textit{LobbyClient.hs}. To solve this the following definitions from the C language has been made in \textit{Main.hs}:
\begin{lstlisting}[language=C]
#ifdef __HASTE__
import LobbyClient
#define disconnect(x) (\_ -> return ())
#else
import LobbyServer
#define clientMain (\_ -> return ())
#endif
\end{lstlisting}
Here it is stated that if '\_\_haste\_\_' is defined i.e. haste is compiling then only import \textit{LobbyClient}, but also make a dummy definition of the \textit{disconnect} function. This since the real disconnect function is defined in \textit{LobbyServer.hs}. Likewise if '\_\_haste\_\_' is not defined i.e. ghc is compiling. Therefore only import \textit{LobbyServer} and make a dummy definition of the \textit{clientMain} function which actually is defined in \textit{LobbyClient.hs}. This specific case was needed since the \textit{Data.UUID}, which is a package haste cannot compile, was desiered to be used. This makes the server able to generate UUIDs.

In general, if a Haskell library, which haste can't compile, is desired to be utilised on the client side then the server would need to provide it through a remote function and return it in some data type which haste can handle.



\subsection{Updating the client}
\label{sub:updating-client}
% Issues encountered when trying to update the client when a state change has happened on the server.
In traditional client-server programming there are multiple ways for the server to notify the clients on changes to the server. The client can, for example, listen to changes via Websockets or Server sent events. The programming model of Haste.App, however, prevents this type of communication. The programming model is meant to be linear and client-centric so the client has to initiate all communication. This leaves two methods: Creating a process client-side that asks the server for some state it wishes to update, or creating a synchronous channel that the server can write to and the relevant clients can read.

The first method, reading a state from the server, is the most intuitive of the two to construct. It is also in line with the client-centric model of Haste.App, which makes the program flow easy to understand. However, this method drains unnecessary resources as it requires the client to have a process reading the state of the server every x number of seconds. Upon reading the state the process has to determine if there has been any change and then update accordingly.

The second method, reading a synchronous channel, solves the problem with consuming resources that the other method suffers from. The method is, however, more complex in it's construction. Each client will need to have a channel for each communication purpose. Since the channels are created and kept by the server, there has to be a server method for reading each channel. Reading from the channel is a blocking operation so there will, for each channel, be a process waiting to read. Upon reading a value from a channel, through a remote call to the server, the client will need to determine what to do with the message and then update accordingly.


\section{Method}
\label{sec:method}
To reach a conclusion regarding the purpose of the project a number of methodologies and ways of evaluating the performance, programmer productivity and stability will be used. To evaluate if the purpose of this thesis is satisfied an implementation with Haste.App will be created. Specifically a Lobby system for games will be developed together with an implementation of the well known game Chinese checkers. Further evaluation will be based on observations and tests done during or after the creation of the software. How the evaluation of these areas of interest will be done is discussed in more detail below. Throughout the process of creating the lobby and game all comments regarding Haste and Haste.App, in particular bugs or inconveniences, will be collected and forwarded to the developer of Haste and Haste.App.


\subsection{Performance}
\label{sub:method-performance}
There are several different aspects that needs to be taken into account in order to assess the overall performance of the application. Most notably, the speed of the application needs to be measured. Because the application is hosted on a web page there are primarily two metrics to be considered when measuring it's speed. The amount of bandwidth sent between the server and the client and how much system resources are used by the application, both on the server side and client side.

The bandwidth required by the application can further be divided into two parts: Firstly, the amount of data that initially needs to be sent when a new client connects to the server, including all the static content as well as the JavaScript code generated by Haste. Secondly, the amount of bandwidth required during the time a player plays the game and when the player is in the lobby. This data will have to be compared to other sites offering similar content (a lobby and a game) to assess if the application requires a reasonable amount of bandwidth for what it does.

The system resources used by the application are defined by the total CPU-usage and the amount of RAM required, both on the server side and the client side. This data can however be hard to analyse since it will be heavily influenced by both the hardware of the clients and server, and how well optimised the code is. The optimisation will also be affected by how optimised the code generated by Haste will be. The data will, on the client side, be compared to other games played in a web browser.

There are also a couple of obvious observations regarding bandwidth and resources that can be made: If the game or lobby appears to be experiencing lag or large amounts of latency. If the client computer or server becomes slow to use when playing the game (which can be an indication of memory leakage).

\todo{Mention how to measure performance (maybe by using wireshark or what have you)}

\subsection{Stability}
The stability of the application is primarily measured by the amount of unrecoverable errors that occurs on either the client or the server. An unrecoverable error is an error that can not be handled by the application and forces a reset of the application state. In order for the application to be considered stable such errors can not happen frequently. These errors can occur during a variety of states that the system has to be resistant to: when the server gets updated during an active session, if the client has outdated JavaScript when trying to communicate with the server, runtime errors on the server, runtime errors on the client JavaScript.

\subsection{Programmer productivity}
Assessing the programmer productivity of writing client-server applications using Haste.App
is mainly about the effort put into writing the program. One crucial aspect in programmer productivity is assessing whether or not the strong static type safety of Haskell reduces the number of hard-to-find errors. The programmer productivity is also heavily influenced by errors present in Haste (not very likely) or Haste.App (more likely). It may also be influenced by the client centric and linear programming model of Haste.App as it claims to make the flow easier to grasp \cite{ekblad2015seamless}. It is however hard to measure the programmer productivity. One metric to consider is if the application is completed faster than estimated in this report. Another metric is to gather data about how long it has taken others to write similar applications using a different programming model.

\subsection{Lobby system}
The main reason for using a lobby system is for communication purposes, thus allowing thorough testing of the Haste.App library because it heavily relies on client-server communication. The scalability and performance will be tested through the lobby since it does not have any theoretical upper limit of connected clients nor the number of concurrently running games. The aim is to find, if it exists, a correlation between performance and connected clients. A correlation will hopefully point out, with a decent amount of precision, when the drops in performance occur.

The lobby is a system where connected clients can start conversations with each other, spectate currently active games, or create their own session of the game. When creating a new session other clients are able to join until it gets full or until the creator starts the game, thus enabling games to be played.

\subsection{Chinese checkers}
\label{sec:chinesecheckers}
Chinese checkers is a turn based board game. Despite it's name, the game originates from Germany. The rules are fairly simple, each player is assigned checkers of one color. The goal is to move all your checkers to the opposite side
of the board, where the holes are the same colour as your checkers. The six basics moves which you can make with a checker are: top right \& left, bottom right \& left, left, right. Of course you may only move your checker to either one of those positions if they are empty. In case some position is not empty (any checker being placed there), you can jump over that specific checker. Jumping over a checker makes you eligible to move again, though with a few requirements: you must move the same checker again and you have to continue jumping over other checkers.
\todo{Maybe create a picture showing all the available moves, increasing the clarity significantly}

The game will be relatively simple, since focus is mainly on the lobby system and the game is only an example used to test it. Chinese checkers is a turn-based game which fits Haste.App since it might not be suitable for dealing with demanding real-time applications. It is also a multiplayer game not only for two players, but up to six players making it able to test many properties of the lobby systems match making feature, and simple to test the scaling factor of the game. The game logic is simple and easy on computational requirements and therefore the server can handle more games at the same time. The purpose of the game is also to test the performance of the outputted JavaScript and the performance of the server code to help determine the suitability of Haste.App when dealing with common applications.

Chinese checkers is implemented with an overview perspective, the balls are colored circles and the holes are represented by squares. The following rules applies to the implementation of Chinese checkers: The objective of the game is to move all your pieces to the opposite side. At each turn one can move a piece one step or jump over another piece. If a player jumps over a piece he can choose to gain an additional move. The first player to get all his pieces over to the opposite side wins.


\subsection{Development}
\todo{A lot of implementation details are mentioned in this section, maybe we should rename it to Development/Implementation or move, just an idea}
The process of development was split into two parts: the game and lobby system, which where both developed in parallel.
This section describes in a slightly chronological manner how the development was done and crucial decisions which had to be made.

\subsubsection{Game}
Before creating functions that apply the game rules the first thing that needs to settled is how to model the game. The $Content$ data type was created to represent what every position can actually hold: it is either $Empty$ or it has a colored checker, which is represented by the data contructor $Piece$ $Color$. The next crucial data type is $Square$. $Square$ is a product type containing a: $Color$, $Content$ and $Coord$. The $Coord$ type is simply a type synonym for $(Int,Int)$, representing the game logic coordinates. Now the game table can be defined, and it is represented by the $Table$ type. $Table$ is also a type synonym for $[Square]$.
\todo{A lot of types are mentioned, complementing the text with a picture showing how the types are related might be good}

Taking the decision to create $Coord$ and $Table$ as type synonym instead of creating new types is mainly due to having sufficient type safety in the other types. It relieves us from having to pattern match each type.

It is worth mentioning that the game was intended to be developed as a two dimensional list, because it already provides natural coordinates. This would then allow for the $Coord$ type to be completely omitted. It required, however, that several basic functions that already existed for the ordinary one dimensional list, to be re-implemented for two dimensional lists. This means that choosing the one dimensional list, we could use the existing rich library of functions already available, thus potentially saving time and effort.

When a solid foundation of functions implementing the game rules were created, it was time to test the functions. Our primary source for finding bugs was QuickCheck. Besides QuickCheck, functions for playing the game from stdio was also created. This allowed us to play the game from a terminal, thus together with QuickCheck verifying the correctness before moving on to creating the graphics.

When the game-logic seemed to be done, it was time to temporarily leave the world of pure Haskell and to actually start using Haste. Concerning the game development, Haste will only be used to generate the graphics and to add interactive functionality. This will of course be translated to JavaScript and run och the client side.

It was decided that the physical holes in the game would be represented as squares that have a content in it. A content can be either empty or a piece. A Square has also a color to represent the target for the pieces with the same color. Lastly Squares has a coordinate in the Cartesian coordinate system which is partly to distinguish the squares from each other and partly to draw them at the right place.

Except for a game table, a way to represent the current state of the game, eg. current player, table etc is also necessary. For this purpose the $GameState$ type was created. $GameState$ contains the following: a $Table$ holding the current game table, $Players$ which is of type $[(Player,Color)]$ containing all the active players with their respective color, $CurrentPlayer$ representing the current player and is of type $Player$, $MoveAgain$ which is of type $Bool$ used for check if the player if the current player can move again. $Player$ is just a type synonym for $String$.

The $Players$ entry in the $GameState$ type is implemented as a regular queue, meaning that the next player is the head of the list and the current player is put last in the list.

The caller who wants to start a game does not have to worry about any initializing of the $GameState$, it only requires a list of player names. Based on the length of that list the correct game table is chosen (removing the checkers not in use), and unique colors for each player is also assigned.

QuickCheck has mostly been used to test the game logic functions. $Square$ and $Content$ was made instances of arbitrary. This enables us to generate completely random game tables. $Content$ also uses frequency to less frequently generate $Empty$ data.



Graphics
The physical checkers and holes were represented by colored circles and white circles. The board however was drawn black to clearly view the holes (see figure x). The graphics in (figure x) was all drawn by using the basic draw and fill functions available in the Haste library. Since the graphics looked primitive and extremely outdated, it was determined that the graphics would be upgraded to represent the physical checkers and holes as images (see figure y). These images were imported bitmaps which will be hosted on the server.
\todo{Add a picture comparing the graphics of the old and new game and explaining differences etc.}

To show when a checker is marked, it was determined that it was clearer and looks nicer to high-light a checker by changing the brightness and the contrast instead of drawing a circle around it.

The game required a rotate button for a player to be able hand over his turn to the next player. This button is only used if a player jumps over a checker or if the player decided to not move during its turn, otherwise the game rotate player automatic.

All the interaction with the game is done via the canvas on which the game table is drawn. This of course calls for an on click functionality which was
implemented in Haste with ease. The code which drives the game is thus executed upon clicking the canvas. Firstly, the actual clicked coordinates relative the canvas are parsed to represent the game logic coordinates. The game state is stored in a MVar and is only accessed when clicking on the canvas.

After the game logic and graphics were done the remaining part was to integrate the game with the lobby. Each client has their respective GameState stored locally. Changes done to the local state is communicated to the rest of the clients through a channel received by the server. The channels used were from the Control.Concurrent package. The server does only handle sending the information received from one channel to all the other client so they can update their state respectively.

To avoid sending the whole game state over the network the new data type GameAction was created. GameAction represents each of the possible manipulations a client can do to their local game state. After making a change to the current game state a client sends the proper GameAction data constructor. Upon receiving the GameAction the other clients parse it and make the necessary changes to their local game states.

The previous main functions used for drawing the game and added the onClick functionality now has to be recreated as a function, namely drawGame. drawGame will be called from the clients main function. The ChineseGraphics file was also
made a module, for enabling it to be imported to the client side application.

The previous main function did not take any arguments. When transforming the main function to drawGame this now has to be changed. Perhaps the two most notable argument changes related to integrating it with the lobby is
adding a div argument and a channel. This means that the lobby gives clients a div where the game related graphics can be drawn. The lobby also supplies the game with a channel where it can send the GameAction commands based on what move the client made.

The channel will be written when the client makes a move, thus the code will be placed inside the onClick functionality. This part is where trouble started occurring when using the Haste compiler. The MVars from the Control.Concurrent package has been used without a flaw inside the onClick function, but the channels from the same package did not behave well. Writing to a channel works fine, but any other operation such as reading, checking if the channel is empty etc. did not work. The application simply crashes when using any of those operations. This is unfortunate since the Haste.Concurrent package does not contain any channels nor an intuitive substitute.




\subsubsection{Lobby system}
%development of the lobby
The development of the lobby system started out straight forward. The first goal was to create a system that allowed for players to enter the lobby, create a game and then start that game when enough people had joined. It should also be possible to see which games are active and who the other players in the lobby are. This might sound simple enough, but this proved to be somewhat more complex than first anticipated.

The problem with updating the client was quickly encountered as players join the lobby and start games continuously. The methods discussed in \cref{sub:updating-client} were evaluated and while the first method was initially used, the obvious advantages of the second method soon made the group switch to creating several channels, one for each type of communication, on which messages could be sent to the client to notify it of a change in state.

Dependencies with GHC and Haste was also a problem that was encountered early in development. This problem with dependencies is discussed in \cref{sub:dependencies}. In order to give the games a unique identifier it was decided to use the library \textit{Data.UUID}, which can't be installed with \textit{haste-cabal}, thusly forcing a very sharp separation between Server and Client code.

Password management for the games are hashed by the library \textit{Crypto.PasswordStore}. The library does, however, not work when compiled with Haste. Because of this all passwords are sent in clear text to the server where they are hashed and stored. This approach would work if Haste.App provided secure web sockets. As it is, however, a malicious person can intercept the communication and see the passwords. 

\todo{How much are we supposed to write about the development of the lobby?}



%UML modell över hur hastings är uppbyggt?
%Limitations vi stötte på. cpp definitioner för att ha dummy definititions av funktioner som inte ska användas
%Val av datatyper för att strukturera upp spelare, spel, koppla till sessionIDs m.m. Saker som syns

\subsubsection{Haste and Haste.App}
\todo{Should this subsection be in Development?}
In this section both advantages and disadvantages of developing an application using Haste and Haste.App will be outlined.

Generating HTML is hard. There aren't that many functions provided by Haste in the first place and those that do exist operate on a low level. The functions operate in a linear way on different HTML elements such as $<div>$ or $<body>$ by first getting an element by its id and then either modifying that element or appending other elements as children, making the code very verbose. This is in contrast to HTML where the contents are laid out in a hierarchical tree. The difference between Haste and HTML primarily creates problems with the maintainability of the code.

Because Haste is still a very new product (the version at the time of writing this paper is 0.5.4) the development of Haste is both very active and an update to Haste could introduce breaking changes to the API. In addition while there exists many mature Haskell libraries which are available to use the libraries that exist for Haste are both very few and more often than not require a specific version of the Haste compiler to work. \todo{Highlight specific problems that this causes?}

One thing that could be considered positive with this seamless programming model is that both the client and server logic is written in the same language. This then no longer requires the programmer to know two different languages. Putting all the logic in one file also appears more natural since the client and server programs are often seen as one, not as two different applications.

%
%Things to write about haste and haste app specific things regarding development
%1. HTML generation is hard with haste
    %2. This makes larger projects dependent on third party libraries or more development time
%3. In general not suitable for large project where everything is written in haste, why?
%   a) Redirection between pages disconnects client from server
%   b) No integrated way to handle multiple pages in a good way
%   c)
%4. No network protocol errors due to static type checking, quantify the importance of this
%5. Client-centric approach is counter-intuitive if you are used to a more traditional client server approach
%6. Despite this good things about the client-centric approach. pls
%7. Rapid development of haste introduces breaking changes, especially for third party libraries, this makes it hard to %develop for haste?



\section{Results}
% How we arrived at these results,
% strict objective results.

The aim of this thesis was to evaluate, based on a few topics, how suitable Haskell using Haste.App is for web development.
The topics were: stability, programmer productivity and performance.

The result is split into two parts. The first part addresses what was actually created, namely the game and the lobby and their respective functionality. The second part presents the results of the three points of interest, and will be evaluated as described in \cref{sec:method}.

\subsection{How the game and lobby became}
\label{sub:game-lobby-results}
The game of chinese checkers was created with rules described in \cref{sec:chinesecheckers}.

The lobby system became a system that does a number of things: One, it is possible to start a game and have others join. Two, it is possible to chat with fellow players. Three, the owner of the game can change settings of the game, increasing the maximum number of players and changing the name. Four, it establishes a connection to a database where all connected clients and games are stored. \comment{Add more things it can do}.

The source code can be found at \url{https://github.com/DATx02-16-14/ChineseCheckers} and \url{https://github.com/DATx02-16-14/Hastings} respectively. The application can, for a limited time, be found at http://www.hastings.se/. 

\subsubsection{Security}
A problem with using Haste.App is the fact that it does not currently support secure communication using HTTPS. It is possible to manually force a HTTPS connection via web server settings but since the Web Socket connection between the client and server is handled by Haste.App that connection remains unencrypted. For the user this results in a completely blank page since most web browsers does not allow a website to partially load resources from an unencrypted source. In practice this means that is that any sensitive data sent between the client and the server such as passwords can easily be picked up by an attacker.

A partial solution to this problem would be to encrypt the passwords manually on the client and decrypt them on the server, there are however several problems with this. Firstly the library used in this project did not work client-side, there might exist another library that does work but none were found that were suitable. Secondly and most important, implementing security and encryption correctly is very hard. Because there already exists a widely used and tested way of encrypting data sent over the web, namely HTTPS, that way should always be preferred. 

\subsection{Results regarding performance}
\todo{Time complexity analysis of important code parts, to justify that performance does not suffer from poorly written code}

Performance of the application is measured by, as stated in \cref{sub:method-performance}, bandwidth required and system resources used. The bandwidth taken into account is primarily the bandwidth required to send the JavaScript since the bandwidth required to send images, text, and other static content is not specific to Haste.App. Moreover, the bandwidth required when communicating with the server is also considered to make sure the client centric programming model does not yield an unnecessary amount of network traffic. Furthermore, the system resources used on the server is measured, in respect to how many active players are online and how many active games are being played. Above that, the system resources used on the client is measured.

The bandwidth required when loading the site seems not to be a problem. The length of the initial packet sent when establishing connection to the server, which contains the JavaScript, is 339 bytes. \comment{Compared to other such sites?}

\todo{Write about system resources}


\subsection{Results regarding stability}
The stability of the application was considered out of four aspects: updating server, client with outdated JavaScript, runtime errors on the Server, and runtime errors on the client.

Because of the static type checking the amount of runtime on the client errors were drastically reduced compared to when writing regular JavaScript. It did, however, not completely rid the application from them. Worth noting are errors that are recoverable which seem to be inherent to Haste, namely when there is an input field. When first typing in the input field it throws an error with the message \textit{Uncaught [object Object]} and when continuing to write it throws and error with the message \textit{Uncaught Infinite loop!} for every letter. The errors does however not seem to have any effect on the application. The unrecoverable errors that can occur do so when working with the DOM, and specifically when trying to retrieve objects with ID's that does not exist. This is however a problem a programmer has to deal with regardless of using Haste or JavaScript directly. Other than those errors, which can be completely avoided by rewriting some code, there are very few errors than can occur. The errors that do occur seem to be inherent to JavaScript being loosely typed. 

Moreover, the server also very rarely has runtime errors. This, however, is not as exceptional as back end servers are most often not written in a language that is quite as error prone as JavaScript. What is more exceptional is that the programming model, with tightly written communication, appears to work very well. There has been no instance of a crash or bug occurring because of a network communication problem. 

Updating the server, however, seems to be a very prominent issue with Haste.App. There is currently no way of updating the server without disconnecting all clients connected. As the communication is handled via web-sockets, these close when the server is restarted and as such there is no way of resuming the same connection. The client has to restart the connection and thus it has to restart from the same state it was in when it first connected to the server. There doesn't seem to be any way of keeping current connections alive while updating the server so that new connections receives an updated state. So if there is any interest in continuing a session when updating the server an additional module has to be written that saves the state of the player when updating the server. It is, however, possible to make use of a database to store values about a connected session and Haste has support for HTML5 Web Storage. These tools together can be used to allow a client to reconnect to the same session as when the server went down.

\todo{Rewrite this entirely, was written with standalone in mind}
Furthermore, the JavaScript will never be outdated. Since there is no way of updating the server without closing the connection for all clients, all clients have to reload the page when the server updates it's state. When this happens the new JavaScript is loaded and as such there will not be a problem working with outdated JavaScript.

\todo{Not sure if this belongs here}
Moreover, overall correctness and stability of the application can be asserted using the QuickCheck library which has support for testing both pure and monadic functions. This enables testing various states and function calls with arbitrary values. While this is a huge benefit of using Haskell, it is not specific to Haste or Haste.App, other than that a lot of the functions are monadic which forces the use of the monadic part of QuickCheck. The static type checking of Haskell eliminates all semantic errors, and QuickCheck allows the code to be tested for logical errors. 



\subsection{Results regarding programmer productivity}
Programmer productivity when writing a web application using Haste.App was heavily influenced by a number of factors. A large influence, compared to writing pure JavaScript, is the fact that Haste is based on Haskell. This, of course, has the typical advantages and disadvantages of writing programs in a declarative paradigm. While it isn't this papers purpose to discuss declarative versus imperative programming and the productivity effects of that, a couple of outstanding productivity differences between Haskell and JavaScript will be accounted for. Other influences on programmer productivity have been debugging and errors, database usage, the linear, client centric approach taken by Haste.App, and the fact that the whole application is written in the same language in the same project. \comment{Add more as more subsubsections are added}


\subsubsection{Haskell versus JavaScript during development}
As previously mentioned, the purpose of this paper is not to discuss the declarative vs imperative paradigm. There are however some notable differences in writing Haskell versus writing JavaScript, which heavily influence programmer productivity. These factors include the type system, the fact that it produces less code, the learning curve of Haskell, \comment{Add more things that influence Haskell vs JS}

One clear advantage of writing the client side code using Haskell instead of JavaScript has been the static type system of Haskell. Allowing types to be checked in compile time has reduced the number of bugs encountered to a very limited set of runtime errors, and considering the points discussed in \cref{subsub:runtime-errors-debugging} this has been a very good thing. Instead of having to check the types of a function or data type (or object as it would have been in JavaScript), one can simply rely on the static type checking to report any type errors and then correct them. Above that, since the type checking can also be used "over the network", type checking network code is also an easy matter, as the compiler does that. 

Another advantage is the fact that the amount of code lines are fewer than in a language such as JavaScript. This means both that the functions are quicker to write, and that the lines of code to maintain are fewer. Compared to JavaScript, even if the purpose of a function and how to write it is clear, it most probably contains a lot of lines of code. In Haskell it is often the case that when one grasps how to write a function, it is simply a matter of a couple of lines of code. 
% Less code - easier to maintain
% Mer logiskt - återanvända saker mycket lättare

However, one disadvantage is the steep learning curve of Haskell. JavaScript has the advantage of being a very easy language to learn\todo{Should this be cited?}, while Haskell is generally considered harder. While this technically means that Haskell is a more advanced language, it also means that a lot of developers have a hard time getting into it. This is a clear disadvantage for Haste.App since it means that there are fewer developers willing to go through the trouble of learning Haskell in order to use Haste.App. Moreover, since Haskell is such a small part of web development, there is not a huge base of developers to draw into the world of Haste.App. 



\subsubsection{Runtime errors and debugging} \todo{Not sure where this belongs}
\label{subsub:runtime-errors-debugging}
One disadvantage with using Haste.App is that when runtime errors occur in the JavaScript code it is almost impossible to debug properly. This is because Haste creates JavaScript that is not suitable for humans to read, variable and function names are automatically generated and all white space is removed. In addition any error messages generated are always generic and doesn't provide any useful information, an example of such error messages are "Uncaught [Object object]" or "Uncaught infinite loop". The only way to narrow down the scope of where the problem might occur is if an exception or error message is generated in response to a specific action taken by the user, in this case it might be possible to narrow down the problem to a specific Haskell function. But even then often the only way to tackle the problem is either to have a bit of luck and spot the problem by just looking at the code or, which is usually the case, remove parts of the code until the error is not generated anymore and from then narrow the error down to the correct row.

When using other programming languages and indeed when programming Haskell without the use of Haste, a debugger is usually provided which enables the programmer to pause execution of the program at a specific code snippet and look at the state of the program as it is executed line by line. When debugging Haste code the usual method is instead to litter the code with print statements that after every computation prints out some or all of the interesting values for that particular code. This is both more time consuming and more error prone since the newly introduced code has to be removed when the problem is eventually solved and additional code can introduce new errors. Introducing new code in order to debug a function is also time consuming, since the program must be recompiled every time a new value needs to be printed. This problem is further compounded by using Haste since the code is compiled twice for every change made, once for the server and once for generating the JavaScript.

There's one final limitation with working with the generated JavaScript and that is when the errors that occur are purely logical, i.e. errors in the code that is neither caught by the compiler nor generate runtime errors but nonetheless yield the wrong result for a computation. In this case the debugging method of choice is the same as before, introducing print statements to monitor the result of different computation. The difference is however that it can be almost impossible to efficiently narrow down the area where the problem might occur and often some amount of guesswork is needed in order to get to the function causing the problem.


\subsubsection{Database usage influence on programmer productivity}
Working with a database in Haskell can vary a lot depending on which package is chosen to handle the functionality, since there is no easy way to save data in a database using native Haskell code. In this project the a MySQL server was chosen to handle the persistent storage for the server and the packages Persistent\cite{persistent-yesod} and Esqueleto\cite{esqueleto-hackage} was chosen to interface with the MySQL server from Haskell code. Persistent contains most of the functionality used, including declaring type-safe SQL tables in Haskell code as well as Haskell functions that supports basic queries on the database, for example, inserting, deleting or updating data. Esqueleto extends the functionality of Persistent to allow the user to generate custom, type-safe SQL queries that are more complex than the functions provided by Persistent.

There are several benefits to working with database libraries that extends Haskel's type system to the SQL domain. By far the most important benefit is the ability to declare SQL tables using TemplateHaskell\todo{Write about template Haskell in technical background?}, Persistent then expands that Haskell code into a valid Haskell type with all the necessary code to also be exported as an SQL table. Because of this the values returned by the functions that interface on the database can be saved directly into a variable with the correct type. There is no need to explicitly declare the different types of fields and the variable is ready to use as is. The same benefit is clearly seen when using Esqueleto to create custom SQL queries, both the general types for different tables as well as when comparing individual values to filter the selection from a database. This has led to a very striking result, when developing this application not a single runtime error has occurred from the result of a bad SQL query, as soon as the query compiles it is correct and will not return an error when executed.

Another advantage is the fact that it is not possible to make changes to the structure or types of a table and introduce an error that way. Normally when working with SQL it is possible to make changes to some part of the database that is neither accessed nor modified very often by the program. In this scenario it could take hours or days of running the program before the error occurs. It is of course possible to have a test suite run to detect errors like this but the programmer still has to manually sift through the code and find every occurrence of a query that relates to that particular table. If even one occurrence is overlooked the program will at some point throw a runtime error and the functionality related to that part of the program will not work or the program will simply crash. This problem is completely eliminated when working with type checked SQL tables and queries, as soon as a change is introduced, even if it's just a simple change of a name every SQL query related to that table will generate a compile time error.

There are some disadvantages to working with Persistent and Esqueleto as well, the most prevalent one is the steep learning curve of especially the Esqueleto library. Persistent on the other hand is relatively easy to grasp and shouldn't require more time than any other database library in terms of understanding the basics and getting it to run in the application. Esqueleto is different in that regard since it's almost as learning a new language, in addition to SQL. The keywords are the same when using Esqueleto compared to ordinary SQL, to insert something the function insert is used, to select something the function select is used and so on. However to enable the rather advanced functionality of Esqueleto the set of operations and operators available through Esqueleto are rather large and the Haskell code required to generate a specific SQL query does not always have the same structure. This translated to about 30 hours of research in order to get sufficiently proficient in Esqueleto to be able to use it effectively. When compared to the estimated time of a couple of hours to use a library that executes SQL queries as strings the learning time is substantially larger. From this another problem is apparent, another programmer who is proficient in SQL but not Esqueleto might have trouble understanding how a particular function works.


% Working with a MySQL database in haskell, Persistent and Esqueleto.
%Pros: Type safe, no errors in expected behaviour when the code compiles, native haskell types <--- very good
%Cons: Confusing syntax (Template haskell and Esqueleto), in some way you have to learn another language in addition to SQL, extremely steep learning curve (about 30 hours to get it to work when knowing SQL already)
%Kerp: fyll i här om hur det är att arbeta med databasen.



\subsubsection{Client centric and linear program flow}
% Describe how the client centric approach has influenced programmer productivity.
The linear, client centric approach taken by Haste.App has had both positive and negative effects on programmer productivity. On the positive side, it has helped in reducing the amount of confusing errors that can occur because of the server and client operating at the same time. It has also helped in understanding the flow of the program as the server only responds to requests made by a client. On the negative side, it has forced the construction of a way to communicate sate changes to the client with the help of concurrent channels, something that might have been easier to construct if the server could act as more than a state. 


\subsubsection{Program in one file}
\todo{What to call this? Should deal with programmer productivity effects of writing the entire program in the same file.}
Being able to write the entire application in the same project or file has had a significant boost to programmer productivity. Not only the fact that the programmer is relieved of dealing with the network communication, and as such allow the type checking to check remote calls. It is also helpful that the entire application is written in the same language. However, the fact that the same sources is compiled twice with different compiler has led to some annoying issues with dependencies.

Firstly, the fact that the programmer never has to consider the network communication may not be a large issue if one is comfortable with network communication. However, for someone new to the field it can be a huge relief. As such it has a positive effect on programmer productivity since the communication is built into the structure of Haste.App. Above that, the simple fact that all network communication is type checked also has positive effects on programmer productivity since it removes confusing network errors from the application.

Secondly, using the same programming language throughout the application also has a positive effect on programmer productivity. Both because a programmer doesn't have to be confident in two different languages in order to construct the application, but also because the same code can be reused on both the client and on the server. However, during the construction of Hastings barely any of the code written has appropriate reuse on both the client and the server. As such the effects of this are rather small. It is however still useful not to have to change language when switching between client code and server code.

Thirdly, because the same sources, at least to some extent, are compiled twice and since all libraries that work with GHC does not work wth Haste. This led to the programmer having to force a separation between the code that will be compiled with GHC and Haste respectively. This was something that took some time to do, and it made for some confusing code. It requires that every initialisation method in the part of the code that has to be compiled by the two compilers needs to be defined two times. Once for the real method and once using a \#define macro from C++. Which of the two methods to define is then handled by using a \#ifndef macro again from C++, to keep track of which compiler is currently used. 











\subsubsection{Standards}
\todo{Write about what is common in technic2al background?}When developing for the web it is very common to use a framework such as Ruby on Rails or React\todo{cite this claim?}. Frameworks have determined certain standards regarding the structure of the code. By using frameworks the programmer can be a lot more efficient in learning the ropes of a new project. Haste.App doesn't have any accompanying framework. Thereby every project has a great potential to be unique in some way. In some cases this can be good for the application being built but at a large this counteracts initial productivity for new programmers to a project.

More in general, it would be helpful to have some preset norms to follow. It would have saved some refactoring, in particular how to structure the views i.e. the generating of the DOM-elements and how they are updated. 

\section{Discussion}
\subsection{Method discussion}
During the initial stages of the project a number of design decisions were made, some of these decisions changed or was altered during development. Here follows a discussion on the various details of the implementation and method of measuring performance, stability and programmer productivity.

\subsubsection{Lobby}
The lobby system experienced various design changes throughout the project. From not being included at all to being what is described in \cref{sub:game-lobby-results}. Here the design choices taken along the way will be discussed.

Firstly, the decision to make a lobby system at all was something that was decided upon early in the development. Creating a lobby system was considered because it would then be possible to test more qualities of Haste.App, than if only a simple game was developed. It allowed testing of aspects such as database usage, secure connections, password management, serving static content, and real time interaction with the server. As such the Lobby has been a useful addition during development. It has, however, made the project substantially larger and made it take more time, while also perhaps being superfluous in that it tests some things that could just as easily been tested in the game by modifying the implementation somewhat. 

Secondly, the choice to include a chat in the lobby has led to being able to test real time interaction with Haste.App in a way that clearly shows eventual delay. The same thing could, however, have been tested in other ways, such as measuring time response from request to the server. It does, however, serve as a proof of concept that Chats, with different people or channels, is possible to implement in an easy way with Haste.App.

Thirdly, implementing a way of dealing with password was also something that the project felt was crucial in assessing the suitability of Haste.App. It also revealed a couple of rather important security issues with Haste.App. This was a crucial decision to uncover these issues, and something that would have been important to implement nonetheless. 

Fourthly, having a database connected to the server side was also something that was important to test. It was important to test since databases are a crucial aspect of web development.


\subsubsection{Game}


\subsubsection{Measuring performance}
Measuring performance of an application is something that isn't very hard. Discussed here will be if the aspects taken into account when measuring performance are enough. 

Firstly, measuring bandwidth is very relevant. If the amount of bandwidth required is too much it is a problem with Haste.App. However, the larger part of bandwidth is more often than not static content such as images or videos. This is not something that Haste.App has anything to do with. The bandwidth required to send the JavaScript, to keep the connection alive, and the communication between server and client are the only aspects taken into account. However, these are often quite small in comparison to media content. As such bandwidth is probably not a huge problem with Haste.App, regardless of if it requires more than other frameworks or not.

Secondly, measuring the amount of required system resources can be a substantially more prominent issue. If the generated JavaScript is very slow or requires an unnecessary amount of system resources (compared to other similar sites) it can be considered to be a prominent issue with Haste.App. The same can be said about the server side, if the server seems to use large amounts of system resources, especially when there are a lot of active clients.

\todo{Discuss how we measured bandwidth and system resources}



\subsubsection{Measuring stability}
What to take into account when measuring stability is a difficult question. Specified here are that stability is primarily measured by the amount of unrecoverable errors. This is a very hard thing to measure since there can be a lot of errors until they are discovered and as such it's hard to know how many unrecoverable errors can occur. However, with the combination of a statically typed system both on client, server, and over communication and decent testing with the help of QuickCheck there aren't a lot of possible unrecoverable errors left. So in this respect Haste.App seems to perform very well, entirely based upon the fact that Haste.App is built upon Haskell.

\subsubsection{Measuring programmer productivity}
%VAAAD SKA DET STÅ HÄR, HJÄLP! JAG HJÄLPTE JU TILL
Measuring programmer productivity is inherently a hard problem since the metrics that can be considered are largely subjective. Especially to measure how much effort is put into a program depends on a lot of factors that range from things that shouldn't be considered such as the previous knowledge of the project participants to things that should be considered such as the general stability and complexity of the library. The problem in this case is to recognise how much the subjective metrics contributed to programmer productivity 

%How we measured programmer producitivity according to method
%Measue the effort put into writing the program
%Measure how errors in Haste and Haste.App influence productivity
%Influenced by the client-centric and linear approach
%If the application is completed faster than expected.
%Gather data about how long it should take.

\subsection{Result discussion}
The results reached regarding performance, stability and programmer productivity are discussed here in regards to how well they met the expectations the project had on Haste.App as well as in what respect the measured results can be disputed. 

\subsubsection{Discussion on performance}
\subsubsection{Discussion on stability}
\subsubsection{Discussion on programmer productivity}
%Positive things from result section
%Using haskell??? type system etc
%Database management
%Program in one file and langauge

%Negative things from result section
%Runtime errors and debugging the client
%Standards?




\subsubsection{Database}
%Compare with other frameworks, rails? javascript?
%Discuss about type safe SQL queries vs strings, pros cons
%In hindsight what should you use? If you know SQL? If you dont?
%Improvements?

%Should we have one discussion section or multiple subsections?
%Pro for one discussion section
%   Method and result may be overlapping. Easier to write discussion in one section
%Pro for multiple subsections:
%   Simply easier to find and skim through the report when you know what you're looking for.

\section{Conclusion}

\end{document}
